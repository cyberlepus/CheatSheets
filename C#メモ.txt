C#メモ

非同期処理
----------------------------------------------------------------

http://gomocool.net/gomokulog/?p=762
なので、Thread クラスは使用しない。Taskクラスでの実装を考える

### メインスレッドからワーカースレッド起動
```
    // 直ぐ実行
    Task task = Task.Run( ラムダ式 );

    // 後からスタートさせる場合
    Task task  = new Task( ラムダ式 );
    task.Start();
```

    task.

### ワーカースレッドからメインスレッドを呼び出す

・次の流れで実装できる
    # 呼び出されるメインスレッドの処理を作成

    ```
      void MainFunc(string text) { メインスレッドの処理 }
    ```

    # メインスレッドの呼び出す関数の型(delegate)を定義
      既に定義されているdelegate型なら(EventHandler 等は)必要ない。

    ```
        delegate  void DelegateMainFunc(string text);
    ```

    # タスクからInvoke()関数を呼び出す
    ```
        Task task = Task.Run(() => {
                :
            Invoke(new DelegateMainFunc(CreateTicket), text);
        }

      Invoke()関数の呼び出しを MethodInvoker でキャストすることでラムダ式で書ける。

            Invoke((MethodInvoker)((string text) => { CreateTicket(text); }));
    ```

デリゲート
----------------------------------------------------------------
### 関数の型を入れる変数




    ラムダ式
----------------------------------------------------------------

### 無名の関数を定義する。
  >  返り値型 関数名( 引数 ){ 処理 }    // 関数
  >  ( 引数 )=>{ 処理 }                 // ラムダ式
  ラムダ式は、関数から「返り値型」と「関数名」を省いて、引数と処理の間に => を入れたような書式となる。
  ラムダ式の返り値型は、処理内にある、return 文から推測される。

### 書式の省略




JSONシリアライズ
----------------------------------------------------------------

### 継承クラスをシリアライズ

    ListViewのアイテムに右クリックメニュー
----------------------------------------------------------------
https://qiita.com/kob58im/items/a5cb6cc89ad2e4ebdf27

    Enum 列挙
----------------------------------------------------------------
https://scrapbox.io/DevelopmentTips/%E3%80%90C%23%E3%80%91enum%E3%81%AE%E5%85%A8%E8%A6%81%E7%B4%A0%E3%81%A7%E3%83%AB%E3%83%BC%E3%83%97%E3%81%99%E3%82%8B